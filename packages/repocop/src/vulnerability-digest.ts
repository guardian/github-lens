import type { view_repo_ownership } from '@prisma/client';
import { stripMargin } from 'common/src/string';
import type { EvaluationResult, Team } from './types';

export function getOwningRepos(
	team: Team,
	repoOwners: view_repo_ownership[],
	results: EvaluationResult[],
) {
	const reposOwnedByTeam = repoOwners.filter(
		(repoOwner) => repoOwner.github_team_id === team.id,
	);

	const resultsOwnedByTeam = reposOwnedByTeam
		.map((repo) => {
			return results.find((result) => result.fullName === repo.full_name);
		})
		.filter((result): result is EvaluationResult => result !== undefined);

	return resultsOwnedByTeam;
}

interface VulnerabilityDigest {
	teamSlug: string;
	subject: string;
	message: string;
}

//TODO test me!!
function createDigestForRepo(result: EvaluationResult): string | undefined {
	if (result.vulnerabilities.length === 0) {
		return undefined;
	}
	const vulnList = result.vulnerabilities
		.map((vuln) => {
			return `- ${vuln.isPatchable ? 'patchable' : 'un-patchable'} ${vuln.severity} vulnerability detected in ${vuln.package} via ${vuln.ecosystem}`;
		})
		.join('\n');
	return stripMargin`
		|${result.fullName}:
		|
		|${vulnList}`;
}

//TODO test me!!
export function createDigest(
	team: Team,
	repoOwners: view_repo_ownership[],
	results: EvaluationResult[],
): VulnerabilityDigest | undefined {
	const resultsForTeam = getOwningRepos(team, repoOwners, results);
	const digestsForRepos = resultsForTeam
		.map((result) => createDigestForRepo(result))
		.filter((digest): digest is string => !!digest);

	if (digestsForRepos.length === 0) {
		return undefined;
	}

	return {
		teamSlug: team.slug,
		subject: `Vulnerability Digest for ${team.name}`,
		message: digestsForRepos.join('\n\n'),
	};
}
