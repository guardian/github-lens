import type { view_repo_ownership } from '@prisma/client';
import type {
	EvaluationResult,
	RepocopVulnerability,
	Team,
	VulnerabilityDigest,
} from './types';
import { vulnSortPredicate } from './utils';

export function getOwningRepos(
	team: Team,
	repoOwners: view_repo_ownership[],
	results: EvaluationResult[],
) {
	const reposOwnedByTeam = repoOwners.filter(
		(repoOwner) => repoOwner.github_team_id === team.id,
	);

	const resultsOwnedByTeam = reposOwnedByTeam
		.map((repo) => {
			return results.find((result) => result.fullName === repo.full_name);
		})
		.filter((result): result is EvaluationResult => result !== undefined);

	return resultsOwnedByTeam;
}

export function getTopVulns(vulnerabilities: RepocopVulnerability[]) {
	return vulnerabilities
		.sort(vulnSortPredicate)
		.slice(0, 10)
		.sort((v1, v2) => v1.fullName.localeCompare(v2.fullName));
}

function createHumanReadableVulnMessage(vuln: RepocopVulnerability): string {
	return String.raw`**${vuln.package}**: ${vuln.severity.toUpperCase()} vulnerability
Introduced to ${vuln.fullName} via ${vuln.ecosystem}
${vuln.isPatchable ? 'Patchable' : '__Not__ patchable'}`;
}

//TODO test me!!
export function createDigest(
	team: Team,
	repoOwners: view_repo_ownership[],
	results: EvaluationResult[],
): VulnerabilityDigest | undefined {
	const resultsForTeam = getOwningRepos(team, repoOwners, results);
	const vulns = resultsForTeam.map((r) => r.vulnerabilities).flat();
	const topVulns = getTopVulns(vulns);
	const message = topVulns
		.map((v) => createHumanReadableVulnMessage(v))
		.join('\n\n');

	return {
		teamSlug: team.slug,
		subject: `Vulnerability Digest for ${team.name}`,
		message,
	};
}
