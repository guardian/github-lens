## RepoCop/Vulnerability API ADR

### Abstract / Background

The DevX Security team has invested efforts into finding owners for every github repository in our organisation. Those
owners have now also determined the production status of their repositories. Both of these are important from a security
perspective so that we can ensure all appropriate security controls are applied to the necessary (production) projects
and that they are appropriately maintained by the owner.

However, new repositories are frequently created and neither ownership or production status are fixed. This means that
we require a system to track and encourage (or enforce) compliance.

Beyond that initial use case, it’s also envisaged that other repository best practices will be verified (e.g. branch
protection.)

### Proposal & Rationale

We should have a service that will check each repository against a set of rules (listed below), and report to teams
where there are violations, and how to remediate.

This service will be called RepoCop.

Vulnerabilities should be sourced from Snyk. Snyk doesn’t report against repositories, but “projects”. We should have a
service that aggregates Snyk data in a way that can be queried by repository name.

This service should be called the Vulnerability API.


### RepoCop Implementation
- **It’ll live in service-catalogue**. RepoCop is a tool to ensure ongoing consistency of the GitHub estate. Service
Catalogue is building information about the GitHub estate. That is, the two have similar concerns.

- **It will be written in Scala 3**. The service-catalogue repository is already a multi-language repository. It's also
important that DevX are comfortable using languages/frameworks that are commonly used across the department. Scala 3
is one of those, and we don't have a project that uses that currently.

- **It’ll run in AWS lambda**. RepoCop will run on a schedule (once a day?), and should not take too long to complete. A
scheduled lambda is a sensible fit for this type of work, and matches that of github-data-fetcher.

- RepoCop should source it’s data from other service-catalogue APIs, rather than directly using third-party APIs
  - We would need to build a new Vulnerability API to cache information from Snyk. This API should be queryable by
repository name.

### RepoCop rules (unordered)
1. _**A repository must have a topic.**_ This helps to determine the production status of a repository.
2. _**A non-archived repository must have at least one team owner.**_ Repositories are required to have a team owner for
smoother handover in case someone leaves or moves to another team. When somebody leaves the org, any individual access
they had to a repository is maintained, so there is a security case for this rule as well as a maintainability one.
(Hackday projects might be an exception to this)
3. _**A non-archived repository must have branch protection.**_ Committing to the default branch (main) should only be
possible via an approved pull request. This ensures that only reviewed code goes to production, with the aim of reducing
the probability of downtime. 
4. _**A non-archived repository must not have individual contributor access for external users without 2FA**_. Similar to
rule 2, individual access remains even if somebody leaves the org, which is a security issue. Not having 2FA is another
security issue.
5. _**An archived repository must not be integrated with Snyk.**_ This is mostly to work around the limits of Snyk, for example a finite set of tags.
6. _**An archived repository must not be running in production.**_ If the repository is archived, we won’t be scanning it
with Snyk, therefore we won’t know if there are any vulnerabilities.
7. _**A production repository must have a .nvmrc file describing the exact node version (if it uses JS/TS).**_ Where exact
is defined as major.minor.patch. Having this allows for the greatest amount of determinism. This also helps ensure
reliable Snyk integration.
8. _**A production repository must not have individual access for org users.**_ When somebody leaves the org, any
individual access they had to a repository is maintained, so there is a security case for this rule as well as a
maintainability one.
9. _**A repository’s default branch should be main.**_ Github's default for the head branch is now main. Many workflow
tools rely on this assumption, and it is considered to be a more inclusive choice of language.
10. _**A production repository should have 0 critical and 0 high vulnerabilities reported by Snyk.**_ Vulnerabilities are bad!


#### Suggested process
1. Get a list of P&E teams from GitHub Lens
2. For each team, list the repositories that have been recently updated
3. Check each repository against the rules (see below)
4. Once a GH team has been processed, send a single report to each team detailing which rules have failed, and link to a
rule definition page (e.g. this one)
   1. The rule definition page should be auto-generated and offer a description and remediation steps
5. All repos without an owner get reported to DevX who will add an owner before the next run (if we rely on a list of
most recent contributors, it may be a bunch of people who’ve left)

### Vulnerability API Implementation

- It is an API that makes up the service-catalogue, therefore it should sit in the same repository
- There should be a data collector (writer), and an API (reader)
- Data should be stored as JSON in S3, with a file per repository
- As a repository can create multiple projects, the data collector should aggregate all project information by
repository and store data on a repository basis.

- It should answer the following:
  - Is the repository reliably integrated with Snyk? (Where reliably is defined as using the shared workflow)
  - If not reliably integrated with Snyk, does the shared workflow file support it?
  - Does the repository have active vulnerabilities?
    - Enumerate all open issues reported by Snyk (ordered by severity?)

#### Suggested process
1. List all projects from Snyk.
2. For each project, find the repository that sourced it, the project type, the latest tag, and a list of open issues.
3. Aggregate project information by repository, and store this view.

### What should be in the MVP?
#### RepoCop
* Police repositories from the DevX SOaR P&E teams
* Apply rules: 1, 2, 9
* Send a notification via email
* Vulnerability API
  - Have a /repo/:name endpoint
    * For repositories integrated with Snyk, return the Snyk project details
    * For repositories not integrated with Snyk, return a 404
  - Have a /repo/:name/issues endpoint that lists open Snyk issues

### What is after MVP?
#### RepoCop
* Policies repositories from all P&E teams
* Applying all rules
* Produce a status page
* 
#### Vulnerability API
* Notify teams of vulnerabilities in their repositories

### Open issues
A discussion of issues relating to this proposal for which the author does not know the solution. This section may be omitted if there are none.

What about repositories owned by the Interactives/Visuals team?
Rather than running on a schedule, could we use GitHub webhooks? (a push model, rather than polling)
What happens if a repository is deleted?
Where should the Vulnerability API store it’s data?



